# Maven总结
## 前言
从工作导线在感觉对Maven一直属于一知半解的状态，会用，但是遇到点问题呢，stackoverflow搜一搜每个答案试一试，能用了就
不再管了，一直这么下来感觉对Maven也没有一个系统的理解，只知道Maven是个项目管理依赖的工具，所以想趁这个机会系统的学习
下Maven，从概念、原理到常用的命令

## Maven简介
Maven是Apache旗下的开源项目，基于项目对象模型（缩写：POM project object model），通过描述信息来构建和管理项目，除了
Maven之外，还有ant和Gradle等主流管理工具
![alt 图片](https://i0.hdslb.com/bfs/album/77dbc011917c4dd0825eff4ab911437757cdcf44.png)
### Maven功能
1. 构建
2. 文档生成
3. 依赖管理
4. 发布
5. 分发
6. 邮件列表

### Maven可以解决那些问题

1. 项目结构混乱，每个人把依赖的配置文件放到不同的位置，那么在下载一个新工程编译会有很多问题
2. 添加管理依赖麻烦

Java 最大的一个优势就是有非常强大的生态，整个生态中有无数的框架和API供人使用。我们在创建实际的项目过程中不可避免地需要用到这些框架和API，而它们通常都是以 Jar 包的形式提供。 相信很多人都经历过 Jar Hell 的问题吧。事实上，让一个项目所依赖的外部 Jar 包保持正确的版本和最新的状态，是件非常苦逼的事情。我们编译项目的时候，需要在 ClassPath 上存放依赖的 Jar 包，而这些 Jar 包还会有其他依赖。你一定经历过递归地一个个去下载所有外部依赖的痛苦过程吧，并且还要确保下载的版本都是正确的，当项目越来越复杂的时候，这是件极其麻烦的事情。

Maven 的出现让我们获得了解脱，Maven 可以自动帮我们做依赖管理，我们需要做的就是在 POM 文件里指定依赖 Jar 包的名称、版本号，Maven 会自动下载，并递归地去下载依赖的进一步依赖。

另外，Maven 还提供一个非常方便的功能---快照依赖。快照依赖指的是那些还在开发中的内部依赖包。与其你经常地更新版本号来获取最新版本，不如直接依赖项目的快照版本。快照版本的每一个 Build 版本都会被下载到本地仓库，即使该快照版本已经在本地仓库了。使用快照依赖可以确保本地仓库中的每一个 Build 版本都是最新的，这对我们快速迭代开发是一个非常酷的特性。

1. 测试代码且测试代码不应发布到线上环境
2. 编译打包部署等麻烦的手工操作

## Maven仓库

在 Maven 的术语中，仓库是一个位置。软件开发中不可避免的需要引入大量的第三方库，这些库所在的位置在Maven中被称为 **"仓库"** 。 在 Maven 中任何一个依赖、插件或者项目构建的输出，都可以称之为 **"构件"** 。Maven 仓库能帮助我们管理构件（主要是JAR）

![maven仓库](https://i0.hdslb.com/bfs/album/9afbb84740639ba94652ff0547d2d923ff00d651.png@1036w.webp)

Maven仓库有三种类型：

1. 本地仓库

在使用时会优先在本地仓库寻找对应的依赖，没有的话会去远程仓库去拉

1. 中央仓库
2. 远程私服 

### Maven依赖搜索顺序

当我们执行 Maven 构建命令时，Maven 开始按照以下顺序查找依赖的库：

- 步骤 1 － 在本地仓库中搜索，如果找不到，执行步骤 2，如果找到了则执行其他操作。

- 步骤 2 － 在中央仓库中搜索，如果找不到，并且有一个或多个远程仓库已经设置，则执行步骤 4，如果找到了则下载到本地仓库中以备将来引用。
- 步骤 3 － 如果远程仓库没有被设置，Maven 将简单的停滞处理并抛出错误（无法找到依赖的文件）。
- 步骤 4 － 在一个或多个远程仓库中搜索依赖的文件，如果找到则下载到本地仓库以备将来引用，否则 Maven 将停止处理并抛出错误（无法找到依赖的文件）。

## Maven标准目录

| ${basedir}                         | 存放 pom.xml 和所有子目录                                    |
| ---------------------------------- | ------------------------------------------------------------ |
| ${basedir}/src/main/java           | 项目的 java 源代码所在的目录                                 |
| ${basedir}/src/main/resources      | 项目的资源文件所在的目录，例如：propert文件                  |
| ${basedir}/src/test/java           | 测试代码所在的目录，例如：JUnit 代码                         |
| ${basedir}/src/test/resources      | 测试相关的资源文件所在的目录                                 |
| ${basedir}/src/main/webapp/WEB-INF | web 应用文件目录，web 项目的信息，比如存放 web.xml、本地图片、jsp 视图页面 |
| ${basedir}/target                  | 打包输出目录                                                 |
| ${basedir}/target/classes          | 编译输出目录                                                 |
| ${basedir}/target/test-classes     | 测试编译输出目录                                             |

![alt 工程目录](https://i0.hdslb.com/bfs/album/5c4c6e147b6c4a73b7471415db9f8eb80ec05a1d.png@1036w.webp)

pom.xml主要描述了项目的maven坐标，依赖关系，开发者需要遵循的规则，缺陷管理系统，组织和licenses，以及其他所有的项目相关因素，是项目级别的配置文件。

## Maven构件

### Maven构件标识

每个构件都有自己的唯一标识（Maven 行话称之为 **"唯一坐标"** ），由 groupId，artifactId 和 version 等信息构成。

- groupId：当前Maven构件隶属的组织名。groupId一般分为多段，通常情况下，第一段为域，第二段为公司名称。域又分为 org、com、cn 等，其中 org 为非营利组织，com 为商业组织，cn 表示中国。以 apache 开源社区的 tomcat 项目为例，这个项目的 groupId 是 org.apache，它的域是org（因为tomcat是非营利项目），公司名称是apache，artifactId是tomcat。(必须)
- artifactId：项目的唯一的标识符，实际对应项目的名称，就是项目根目录的名称。(必须)
- version：当前版本。(必须)
- packaging：打包方式，比如 jar，war... (必须)
- classifier：classifier通常用于区分从同一POM构建的具有不同内容的构件。它是可选的，它可以是任意的字符串，附加在版本号之后

### Maven构件特性

（1）构件具有依赖传递。例如：项目依赖构件A，而构件A又依赖B，Maven会将A和B都视为项目的依赖。

（2）构件之间存在版本冲突时，Maven会依据 "短路优先" 原则加载构件。此外，我们也可以在 pom.xml 中，使用 <exclusions></exclusions>显式排除某个版本的依赖，以确保项目能够运行。

- （a）项目依赖构件A和B，构件A → C → D(version:1.0.0)，构件B → D(version:1.1.0)，此时，Maven会优先解析加载D(version:1.1.0)。
- （b）项目依赖构件A和B，构件A → D(version:1.0.0)， 构件B → D(version:1.1.0)，两者路径一样长，那么Maven会优先解析先声明的版本。

（3）构件的依赖范围**即构件中的scope属性**。Maven在项目的构建过程中，会编译三套 ClassPath，分别对应：编译期，运行期，测试期。而依赖范围就是为构件指定它可以作用于哪套 ClassPath。

| -        | 编译期 | 测试期 | 运行期 | 说明                                                         |
| -------- | ------ | ------ | ------ | ------------------------------------------------------------ |
| compile  | √      | √      | √      | 默认范围                                                     |
| provided | √      | √      |        | 如 servlet-api.jar，运行期由web容器提供。                    |
| runtime  |        | √      | √      | 编译期无需直接引用。                                         |
| test     |        | √      |        | 如junit.jar。                                                |
| system   | √      | √      |        | 必须通过 <systemPath></systemPath> 元素，显示指定依赖文件的路径， 与本地系统相关联，可移植性差。 |
| import   |        |        |        | 表示继承父POM.XML中的依赖范围设置                            |

## 遇到过的Maven问题

### 本地上传jar包之后工程拉不到jar包

**Maven 的 Snapshot 版本与 Release 版本**

1、Snapshot 版本代表不稳定、尚处于开发中的版本。

2、Release 版本则代表稳定的版本。

3、什么情况下该用 SNAPSHOT?

协同开发时，如果 A 依赖构件 B，由于 B 会更新，B 应该使用 SNAPSHOT 来标识自己。这种做法的必要性可以反证如下：

- a. 如果 B 不用 SNAPSHOT，而是每次更新后都使用一个稳定的版本，那版本号就会升得太快，每天一升甚至每个小时一升，这就是对版本号的滥用。
- b.如果 B 不用 SNAPSHOT, 但一直使用一个单一的 Release 版本号，那当 B 更新后，A 可能并不会接受到更新。因为 A 所使用的 repository 一般不会频繁更新 release 版本的缓存（即本地 repository)，所以B以不换版本号的方式更新后，A在拿B时发现本地已有这个版本，就不会去远程Repository下载最新的 B

4、 不用 Release 版本，在所有地方都用 SNAPSHOT 版本行不行？     

不行。正式环境中不得使用 snapshot 版本的库。 比如说，今天你依赖某个 snapshot 版本的第三方库成功构建了自己的应用，明天再构建时可能就会失败，因为今晚第三方可能已经更新了它的 snapshot 库。你再次构建时，Maven 会去远程 repository 下载 snapshot 的最新版本，你构建时用的库就是新的 jar 文件了，这时正确性就很难保证了。